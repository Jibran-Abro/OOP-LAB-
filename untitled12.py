# -*- coding: utf-8 -*-
"""Untitled12.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-SIjFw21y7flUJNk3O-rwdmg03VkQDxK
"""

import tkinter as tk
from collections import deque

# Warehouse grid: 0=open, 1=wall
warehouse = [
    [0, 0, 0, 0, 0],
    [1, 1, 1, 1, 0],
    [0, 0, 0, 1, 0],
    [0, 1, 0, 0, 0],
    [0, 1, 1, 1, 0]
]

ROWS = len(warehouse)
COLS = len(warehouse[0])
CELL_SIZE = 60

start = (0, 0)
goal = (4, 4)

class WarehouseGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("Warehouse BFS Pathfinding")
        self.canvas = tk.Canvas(root, width=COLS*CELL_SIZE, height=ROWS*CELL_SIZE)
        self.canvas.pack()

        self.button = tk.Button(root, text="Start BFS", command=self.start_bfs)
        self.button.pack(pady=10)

        self.path = []
        self.step = 0

        self.draw_grid()

    def draw_grid(self, path_cells=None):
        self.canvas.delete("all")
        for r in range(ROWS):
            for c in range(COLS):
                x1 = c * CELL_SIZE
                y1 = r * CELL_SIZE
                x2 = x1 + CELL_SIZE
                y2 = y1 + CELL_SIZE

                if (r, c) == start:
                    color = "green"
                elif (r, c) == goal:
                    color = "red"
                elif warehouse[r][c] == 1:
                    color = "black"
                else:
                    color = "white"

                self.canvas.create_rectangle(x1, y1, x2, y2, fill=color, outline="gray")

        # Draw path so far
        if path_cells:
            for (r, c) in path_cells:
                if (r, c) != start and (r, c) != goal:
                    x1 = c * CELL_SIZE + 15
                    y1 = r * CELL_SIZE + 15
                    x2 = x1 + CELL_SIZE - 30
                    y2 = y1 + CELL_SIZE - 30
                    self.canvas.create_rectangle(x1, y1, x2, y2, fill="blue")

    def get_neighbors(self, pos):
        x, y = pos
        directions = [(-1,0), (1,0), (0,-1), (0,1)]
        neighbors = []
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            if 0 <= nx < ROWS and 0 <= ny < COLS and warehouse[nx][ny] == 0:
                neighbors.append((nx, ny))
        return neighbors

    def bfs(self, start, goal):
        queue = deque([start])
        visited = set([start])
        parent = {start: None}

        while queue:
            current = queue.popleft()
            if current == goal:
                break
            for neighbor in self.get_neighbors(current):
                if neighbor not in visited:
                    visited.add(neighbor)
                    parent[neighbor] = current
                    queue.append(neighbor)

        # Reconstruct path
        path = []
        current = goal
        while current and current != start:
            path.append(current)
            current = parent.get(current)
        if current == start:
            path.append(start)
            path.reverse()
            return path
        return []

    def animate_path(self):
        if self.step <= len(self.path):
            self.draw_grid(self.path[:self.step])
            self.step += 1
            self.root.after(300, self.animate_path)

    def start_bfs(self):
        self.step = 0
        self.path = self.bfs(start, goal)
        if not self.path:
            print("No path found.")
        self.animate_path()


if __name__ == "__main__":
    root = tk.Tk()
    app = WarehouseGUI(root)
    root.mainloop()